Correlated Queries, Nested Queries, and Common Table Expressions
In this chapter, you will learn how to use nested and correlated subqueries to extract more complex data from a relational database. You will also learn about common table expressions and how to best construct queries using multiple common table expressions.

Got It!
1. Correlated subqueries
Welcome back! You're making fantastic progress so far. Now that you've covered the basics of simple subqueries, let's learn how to construct correlated subqueries.

2. Correlated subquery
Correlated subqueries are a special kind of subquery that use values from the outer query in order to generate the final results. The subquery is re-executed each time a new row in the final data set is returned, in order to properly generate each new piece of information. Correlated subqueries are used for special types of calculations, such as advanced joining, filtering, and evaluating of data in the database.

3. A simple example
Let's walk through an example of one of these queries. In the previous chapter, you completed an exercise that answered the question, "Which match stages, where the stakes get higher in each stage, tend to have a higher than average number of goals scored?"

4. A simple example
You achieved this using 3 simple subqueries in the SELECT, FROM, and WHERE statements. However, the same output can also be produced with a correlated subquery. Let's focus on the subquery in the WHERE statement.

5. A correlated example
This query has only one difference -- instead of including a filter by season, the WHERE clause filters for data where the outer table's match stage, pulled from the subquery in FROM, is HIGHER than the overall average generated in the WHERE subquery. The entire WHERE statement is saying, in essence, "return stages where the values in the subquery are higher than the average."

6. A correlated example
Here are the results generated by this query. This may seem a bit complicated, but with a few more examples and a bit of practice, you will start to get the hang of how useful correlated subqueries can be.

7. Simple vs. correlated subqueries
Let's quickly walk through some key differences between simple and correlated subqueries. Simple subqueries can be used in extracting, structuring or filtering information, and can run independent of the main query. In contrast, a correlated subquery cannot be executed on its own because it's dependent on values in the main query. Additionally, a simple subquery is evaluated once in the entire statement. A correlated subquery is evaluated in loops -- once for each row generated by the data set. This means that adding correlated subqueries will slow down your query performance, since your query is recalculating information over and over. Be careful not to include too many correlated subqueries -- or your query may take a long time to run!

8. Correlated subqueries
Here's another, smaller example of a query in which you can use a correlated subquery. Let's answer the question, "What is the average number of goals scored in each country across all match seasons?" This is an an easy enough question, right? You simply join the match table to the country table on the country's id, and extract the country's name, take an average of the goals scored, and group the entire query by the country's name, yielding one row with an average value per country.

9. Correlated subqueries
A correlated subquery can be used here in lieu of a join. Take a look at the outer query first. The name of the country is selected from the country table, aliased as "c". The second column selected is a scalar subquery, selecting the average total goals scored across all seasons from the match table. You'll notice that the WHERE clause asks SQL to return values where the inner, match table's country_id column matches the c.id column in the outer query's country table. This way, the entire join is replaced, and the results are identical.

10. Let's practice!
Okay! It's time to practice using correlated subqueries.

Basic Correlated Subqueries
Correlated subqueries are subqueries that reference one or more columns in the main query. Correlated subqueries depend on information in the main query to run, and thus, cannot be executed on their own.

Correlated subqueries are evaluated in SQL once per row of data retrieved -- a process that takes a lot more computing power and time than a simple subquery.

In this exercise, you will practice using correlated subqueries to examine matches with scores that are extreme outliers for each country -- above 3 times the average score!

Instructions
100 XP
Select the country_id, date, home_goal, and away_goal columns in the main query.
Complete the AVG value in the subquery.
Complete the subquery column references, so that country_id is matched in the main and subquery.

SELECT 
	-- Select country ID, date, home, and away goals from match
	main.country_id,
    main.date,
    main.home_goal, 
    main.away_goal
FROM match AS main
WHERE 
	-- Filter the main query by the subquery
	(home_goal + away_goal) > 
        (SELECT AVG((sub.home_goal + sub.away_goal) * 3)
         FROM match AS sub
         -- Join the main query to the subquery in WHERE
         WHERE main.country_id = sub.country_id);
         
Great job! Correlated subqueries take longer to produce results, but they often prevent you from having to create multiple subqueries.

Correlated subquery with multiple conditions
Correlated subqueries are useful for matching data across multiple columns. In the previous exercise, you generated a list of matches with extremely high scores for each country. In this exercise, you're going to add an additional column for matching to answer the question -- what was the highest scoring match for each country, in each season?

*Note: this query may take a while to load.

Instructions
100 XP
Select the country_id, date, home_goal, and away_goal columns in the main query.
Complete the subquery: Select the matches with the highest number of total goals.
Match the subquery to the main query using country_id and season.
Fill in the correct logical operator so that total goals equals the max goals recorded in the subquery.

SELECT 
	-- Select country ID, date, home, and away goals from match
	main.country_id,
    main.date,
    main.home_goal,
    main.away_goal
FROM match AS main
WHERE 
	-- Filter for matches with the highest number of goals scored
	(home_goal + away_goal) = 
        (SELECT MAX(sub.home_goal + sub.away_goal)
         FROM match AS sub
         WHERE main.country_id = sub.country_id
               AND main.season = sub.season);
               
Great job! Subqueries can be very useful for selecting data broken into multiple categories -- though you may have to wait for the data to load!


Got It!
1. Nested subqueries
Building on the previous lesson, another important type of subquery to learn is the nested subquery.

2. Nested subqueries?
Nested subqueries are exactly as they sound -- subqueries nested inside other subqueries. As you saw in the previous chapter, information in a database is often not in the format you need to answer a question. Some types of questions you answer may require multiple layers of transformation and filtering of data before you extracting it into the main query.

3. A subquery...
Let's start with an example. The query you see here is similar to a previous lesson where we selected the average number of goals scored in a match within each country, and compared it to the overall average using a subquery in SELECT. This third column calculates the difference between each country, and the overall average.

4. A subquery...
The resulting table looks like this, with one row for each country, and one column for each of the two calculations.

5. ...inside a subquery!
Let's answer a similar question with an additional layer -- How does each month's total goals differ from the monthly average of goals scored? The query here, similar to the previous one, answers this question. Let's take some time to walk through the necessary steps to get this result.

6. Inner subquery
The subquery logic reads like this -- first, select the sum of goals scored in each month. The month is queried using the EXTRACT function, FROM the date. Here are the results of that first, inner subquery, which includes results for months 1 through 12.

7. Outer subquery
Next, you can place the subquery into the second, outer subquery to calculate an average of the values generated in the previous table, giving you the average monthly goals scored. Since this result is a scalar subquery, you can now place it in the main query for calculating the final data set.

8. Final query
Finally, you can place the entire nested subquery in the SELECT statement, giving you a scalar value to compare to the SUM of goals scored in each month. Here are the first 4 rows of the final query, which generates a sum of goals scored in the month, and a column subtracting the goals scored, from the overall monthly average.

9. Correlated nested subqueries
It's important to also note that nested queries can be correlated or uncorrelated. They can also be a combination of the two -- the inner subquery can be correlated, the outer uncorrelated, or vice versa! And each of the correlated subqueries can reference information from an outer subquery, or the main query. It entirely depends on the problem you're looking to solve. Let's look at an example.

10. Correlated nested subqueries
Let's look at another example here. This query answers the question, What is each country's average goals scored in a match in the 2011/2012 season? This is fairly similar to the previous chapter, except it takes one additional step.

11. Correlated nested subqueries
It has a second, nested subquery inside the SELECT statement,

12. Correlated nested subquery
and the outer subquery has a statement correlating with the main query.

13. Correlated nested subqueries
The result you see here is a table with a column that identifies each country's average goals scored in the 2011/2012 season.

14. Let's practice!
Okay! Let's practice creating some nested subqueries.

Nested simple subqueries
Nested subqueries can be either simple or correlated.

Just like an unnested subquery, a nested subquery's components can be executed independently of the outer query, while a correlated subquery requires both the outer and inner subquery to run and produce results.

In this exercise, you will practice creating a nested subquery to examine the highest total number of goals in each season, overall, and during July across all seasons.

Instructions
100 XP
Complete the main query to select the season and the max total goals in a match for each season. Name this max_goals.
Complete the first simple subquery to select the max total goals in a match across all seasons. Name this overall_max_goals.
Complete the nested subquery to select the maximum total goals in a match played in July across all seasons.
Select the maximum total goals in the outer subquery. Name this entire subquery july_max_goals.

SELECT
	-- Select the season and max goals scored in a match
	season,
    max(home_goal + away_goal) AS max_goals,
    -- Select the overall max goals scored in a match
   (SELECT max(home_goal + away_goal) FROM match) AS overall_max_goals,
   -- Select the max number of goals scored in any match in July
   (SELECT max(home_goal + away_goal) 
    FROM match
    WHERE id IN (
          SELECT id FROM match WHERE EXTRACT(MONTH FROM date) = 07)) AS july_max_goals
FROM match
GROUP BY season;

Good job! You just set up a nested subquery inside your main query to get some interesting data.

Nest a subquery in FROM
What's the average number of matches per season where a team scored 5 or more goals? How does this differ by country?

Let's use a nested, correlated subquery to perform this operation. In the real world, you will probably find that nesting multiple subqueries is a task you don't have to perform often. In some cases, however, you may find yourself struggling to properly group by the column you want, or to calculate information requiring multiple mathematical transformations (i.e., an AVG of a COUNT).

Nesting subqueries and performing your transformations one step at a time, adding it to a subquery, and then performing the next set of transformations is often the easiest way to yield accurate information about your data. Let's get to it!

Instructions 1/3
35 XP
Generate a list of matches where at least one team scored 5 or more goals.

-- Select matches where a team scored 5+ goals
SELECT
	country_id,
    season,
	id
FROM match
WHERE home_goal >= 5 OR away_goal >= 5;

Instructions 2/3
35 XP
Turn the query from the previous step into a subquery in the FROM statement.
COUNT the match ids generated in the previous step, and group the query by country_id and season.

-- Count match ids
SELECT
    country_id,
    season,
    Count(id) AS matches
-- Set up and alias the subquery
FROM (
	SELECT
    	country_id,
    	season,
    	id
	FROM match
	WHERE home_goal >= 5 OR away_goal >= 5)
    AS subquery
-- Group by country_id and season
GROUP BY country_id, season;

Instructions 3/3
0 XP
Finally, declare the same query from step 2 as a subquery in FROM with the alias outer_s.
Left join it to the country table using the outer query's country_id column.
Calculate an AVG of high scoring matches per country in the main query.

SELECT
	c.name AS country,
    -- Calculate the average matches per season
    AVG(outer_s.matches) AS avg_seasonal_high_scores
FROM country AS c
-- Left join outer_s to country
LEFT JOIN (
  SELECT country_id, season,
         COUNT(id) AS matches
  FROM (
    SELECT country_id, season, id
	FROM match
	WHERE home_goal >= 5 OR away_goal >= 5) AS inner_s
  -- Close parentheses and alias the subquery
  GROUP BY country_id, season) AS outer_s
ON c.id = outer_s.country_id
GROUP BY country;

Great job!! This required quite a few steps, but you've got the hang of steps necessary to nest subqueries in FROM that you can apply to other parts of your query as well!

1. Common Table Expressions
Great job getting the hang of nested and correlated subqueries.

2. When adding subqueries...
As you probably noticed, the queries we have been setting up are quickly becoming long and complex. It can become difficult to clearly keep track of each piece of your query, why you need it, and whether or not it's necessary. In this lesson, we'll cover a common method for improving readability and accessibility of information in subqueries -- the common table expression.

3. Common Table Expressions
Common table expressions, or CTEs are a special type of subquery that is declared ahead of your main query, just like you see here. Instead of wrapping subqueries inside, say the FROM statement, you name it using the WITH statement, and then reference it by name later in the FROM statement as if it were any other table in your database.

4. Take a subquery in FROM
Let's rewrite a query from an exercise that you completed in chapter 2, by using a CTE. The query you see here uses a subquery, s, in the FROM statement to generate a list of country id's and match IDs that meet a certain criteria -- specifically, we only wanted matches with 10 or more goals scored in total. This subquery is then joined to the country table, and the number of matches in the subquery is counted in the main query. Here are the results of that query -- a short list of countries with very few high-scoring matches.

5. Place it at the beginning
In order to rewrite this query using a common table expression to represent the subquery, simply take the subquery out of the FROM clause, place it at the beginning of your query,

6. Place it at the beginning
declare it using the syntax WITH, followed by a CTE name, and AS. So, here we're starting our CTE, s, by stating WITH s AS, and then placing the subquery inside parentheses. It's now a common table expression!

7. Show me the CTE
Finally, complete the rest of the query the same way you would if the CTE were an existing table in the database. You select the country name from the country table, count the number of matches in the CTE "s", JOIN "s" to the country table, and then group the results by the country name's alias. The results -- you guessed it -- are identical to the previous query setup!

8. Show me all the CTEs
If you have multiple subqueries that you want to turn into a common table expression, you can simply list them one after another, with a comma in between each CTE, and NO comma after the last one. You can then retrieve the information you need into the main query -- just make sure you properly join this second CTE as well!

9. Why use CTEs?
So why are we learning yet another method of producing the same result in a SQL query? Common table expressions have numerous benefits over a subquery written inside your main query. First, the CTE is run only once, and then stored in memory, so it often leads to an improvement in the amount of time it takes to run your query. Second, CTEs are an excellent tool for organizing long and complex CTEs. You can declare as many CTEs as you need, one after another. You can also reference information in CTEs declared earlier. For example, if you have 3 CTEs in a query, your third CTE can retrieve information from the first and second CTE. Finally, a CTE can reference itself in a special kind of table called a recursive CTE. We'll briefly discuss some more advanced applications of CTEs in the next lesson.

10. Let's practice!
For now, let's practice writing CTEs by modifying queries in exercises you completed in chapter 2.

Clean up with CTEs
In chapter 2, you generated a list of countries and the number of matches in each country with more than 10 total goals. The query in that exercise utilized a subquery in the FROM statement in order to filter the matches before counting them in the main query. Below is the query you created:

SELECT
  c.name AS country,
  COUNT(sub.id) AS matches
FROM country AS c
INNER JOIN (
  SELECT country_id, id 
  FROM match
  WHERE (home_goal + away_goal) >= 10) AS sub
ON c.id = sub.country_id
GROUP BY country;
You can list one (or more) subqueries as common table expressions (CTEs) by declaring them ahead of your main query, which is an excellent tool for organizing information and placing it in a logical order.

In this exercise, let's rewrite a similar query using a CTE.

Instructions
100 XP
Complete the syntax to declare your CTE.
Select the country_id and match id from the match table in your CTE.
Left join the CTE to the league table using country_id.

-- Set up your CTE
WITH match_list AS (
    SELECT 
  		country_id, 
  		id
    FROM match
    WHERE (home_goal + away_goal) >= 10)
-- Select league and count of matches from the CTE
SELECT
    l.name AS league,
    COUNT(match_list.id) AS matches
FROM league AS l
-- Join the CTE to the league table
LEFT JOIN match_list ON l.id = match_list.country_id
GROUP BY l.name;

Nice job! You just rearranged a query to produce similar results to a subquery in FROM! Isn't this much easier to read?

Organizing with CTEs
Previously, you modified a query based on a statement you completed in chapter 2 using common table expressions.

This time, let's expand on the exercise by looking at details about matches with very high scores using CTEs. Just like a subquery in FROM, you can join tables inside a CTE.

Instructions
100 XP
Declare your CTE, where you create a list of all matches with the league name.
Select the league, date, home, and away goals from the CTE.
Filter the main query for matches with 10 or more goals.

-- Set up your CTE
WITH match_list AS (
  -- Select the league, date, home, and away goals
    SELECT 
  		l.name AS league, 
     	m.date, 
  		m.home_goal, 
  		m.away_goal,
       (m.home_goal + m.away_goal) AS total_goals
    FROM match AS m
    LEFT JOIN league as l ON m.country_id = l.id)
-- Select the league, date, home, and away goals from the CTE
SELECT league, date, home_goal, away_goal
FROM match_list
-- Filter by total goals
WHERE total_goals >= 10;

Nice job! CTEs are much easier to read than multiple subqueries!

CTEs with nested subqueries
If you find yourself listing multiple subqueries in the FROM clause with nested statement, your query will likely become long, complex, and difficult to read.

Since many queries are written with the intention of being saved and re-run in the future, proper organization is key to a seamless workflow. Arranging subqueries as CTEs will save you time, space, and confusion in the long run!

Instructions
100 XP
Declare a CTE that calculates the total goals from matches in August of the 2013/2014 season.
Left join the CTE onto the league table using country_id from the match_list CTE.
Filter the list on the inner subquery to only select matches in August of the 2013/2014 season.

-- Set up your CTE
WITH match_list AS (
    SELECT 
  		country_id,
  	   (home_goal + away_goal) AS goals
    FROM match
  	-- Create a list of match IDs to filter data in the CTE
    WHERE id IN (
       SELECT id
       FROM match
       WHERE season = '2013/2014' AND EXTRACT(MONTH FROM date) = 8))
-- Select the league name and average of goals in the CTE
SELECT 
	l.name,
    AVG(match_list.goals)
FROM league AS l
-- Join the CTE onto the league table
LEFT JOIN match_list ON l.id = match_list.country_id
GROUP BY l.name;

Fantastic work! Your CTE with a nested subquery is easy to read -- and produces an interesting set of data!

1. Deciding on techniques to use
At this point in the course, you're probably wondering why we're covering so many different methods of performing similar tasks.

2. Different names for the same thing?
That's a great question. The simplest answer is that yes, there is a lot of overlap between use cases for joins, subqueries, and common table expressions. Many questions that you answer can use these techniques interchangeably without sacrificing query run time or the accuracy of your output. But these techniques are not identical.

3. Differentiating Techniques
Let's take a minute to compare the techniques we've been using in this and the previous chapter. Joins allow you to directly combine information from 2 or more tables, and on their own, are mostly limited to simple combinations and aggregations of tables already present in your database. A correlated subquery allows you to combine information between a subquery and a table, or another subquery. These help you simplify your syntax and circumvent the limits of a join -- namely, that you can't join two separate columns in one table, to a single column in another at a time. We saw this in the "match" table, where you can't retrieve the team name from the "team" table for both the home and away teams at the same time. A correlated query can solve that problem. However, it's important to remember that correlated subqueries take a long time to process, and will slow down your query performance. Multiple and nested subqueries are useful when your data requires multi-step transformations before it's in the form you need for your final query. Breaking down the steps of your query process allows for better accuracy and reproducibility in your work. Finally, common table expressions allow you to organize your subqueries sequentially by declaring them at the beginning of your query. Since CTEs are processed one at a time before your main query, you can reference information from a CTE created earlier, thus serving as an alternative to nested subqueries.

4. So which do I use?
So which one do you use? Often, it really depends on the database you're using, the field that you're working in, and the questions that you're asking. In general, I recommend that you practice each technique with your own databases to determine which allows you to best use and reuse your queries and generate clear and accurate results.

5. Different use cases
Before we move on, I'll share a few examples of questions that each of these approaches can be used for. As you've seen, joins are a universally important skill when working with a database that has more than 1 table. It's fair to say that joins are necessary to understand each of the following techniques. Correlated subqueries are great for matching data from different columns in one or more tables, such as determining who each employee's immediate supervisor is. Multiple and nested subqueries are great for answering questions such as, what is the average deal size closed by each sales representative in the last quarter, which would require multiple steps to transform and prepare before generating the final query. Finally, CTEs are excellent for comparing a large number of disparate pieces of information. For example, you may want to create a summary table examining the marketing, sales, growth, and engineering teams' performance on their key metrics last quarter. With CTEs, you can extract data about each team's performance one after another, and combine them into a single query.

6. Let's Practice!
Okay! Let's practice some variations on these techniques to see what your results look like.

Get team names with a subquery
Let's solve a problem we've encountered a few times in this course so far -- How do you get both the home and away team names into one final query result?

Out of the 4 techniques we just discussed, this can be performed using subqueries, correlated subqueries, and CTEs. Let's practice creating similar result sets using each of these 3 methods over the next 3 exercises, starting with subqueries in FROM.

Instructions 1/2
50 XP
Create a query that left joins team to match in order to get the identity of the home team. This becomes the subquery in the next step.

SELECT 
	m.id, 
    t.team_long_name AS hometeam
-- Left join team to match
FROM match AS m
LEFT JOIN team as t
ON m.hometeam_id = team_api_id;

Instructions 2/2
50 XP
Add a second subquery to the FROM statement to get the away team name, changing only the hometeam_id. Left join both subqueries to the match table on the id column.
Warning: if your code is timing out, you have probably made a mistake in the JOIN and tried to join on the wrong fields which caused the table to be too big! Read the provided code and comments carefully, and check your ON conditions!

SELECT
	m.date,
    -- Get the home and away team names
    hometeam,
    awayteam,
    m.home_goal,
    m.away_goal
FROM match AS m

-- Join the home subquery to the match table
LEFT JOIN (
  SELECT match.id, team.team_long_name AS hometeam
  FROM match
  LEFT JOIN team
  ON match.hometeam_id = team.team_api_id) AS home
ON home.id = m.id

-- Join the away subquery to the match table
LEFT JOIN (
  SELECT match.id, team.team_long_name AS awayteam
  FROM match
  LEFT JOIN team
  -- Get the away team ID in the subquery
  ON match.awayteam_id = team.team_api_id) AS away
ON away.id = m.id;

Great job!! This is one clear way to generate a list of team names who played in a match. This is much easier to read than team ID numbers!

Get team names with correlated subqueries
Let's solve the same problem using correlated subqueries -- How do you get both the home and away team names into one final query result?

This can easily be performed using correlated subqueries. But how might that impact the performance of your query? Complete the following steps and let's find out!

Please note that your query will run more slowly than the previous exercise!

Instructions 1/2
50 XP
Using a correlated subquery in the SELECT statement, match the team_api_id column from team to the hometeam_id from match.

SELECT
    m.date,
   (SELECT team_long_name
    FROM team AS t
    -- Connect the team to the match table
    WHERE team_api_id = hometeam_id) AS hometeam
FROM match AS m;

Instructions 2/2
50 XP
Create a second correlated subquery in SELECT, yielding the away team's name.
Select the home and away goal columns from match in the main query.

SELECT
    m.date,
    (SELECT team_long_name
     FROM team AS t
     WHERE t.team_api_id = m.hometeam_id) AS hometeam,
    -- Connect the team to the match table
    (SELECT team_long_name
     FROM team AS t
     WHERE t.team_api_id = m.awayteam_id) AS awayteam,
    -- Select home and away goals
     m.home_goal,
     m.away_goal
FROM match AS m;

Fantastic work! The syntax here is much simpler, but if you're working with a large dataset your query may take a while to run!

Get team names with CTEs
You've now explored two methods for answering the question, How do you get both the home and away team names into one final query result?

Let's explore the final method - common table expressions. Common table expressions are similar to the subquery method for generating results, mainly differing in syntax and the order in which information is processed.

Instructions 1/3
Select id from match and team_long_name from team. Join these two tables together on hometeam_id in match and team_api_id in team.

SELECT 
	-- Select match id and team long name
    m.id, 
    t.team_long_name AS hometeam
FROM match AS m
-- Join team to match using team_api_id and hometeam_id
LEFT JOIN team AS t 
ON m.hometeam_id = t.team_api_id;

Instructions 2/3
Declare the query from the previous step as a common table expression. SELECT everything from the CTE into the main query. Your results will not change at this step!

-- Declare the home CTE
WITH home AS (
	SELECT m.id, t.team_long_name AS hometeam
	FROM match AS m
	LEFT JOIN team AS t 
	ON m.hometeam_id = t.team_api_id)
-- Select everything from home
SELECT *
FROM home;

Instructions 3/3
Let's declare the second CTE, away. Join it to the first CTE on the id column.
The date, home_goal, and away_goal columns have been added to the CTEs. SELECT them into the main query.

WITH home AS (
  SELECT m.id, m.date, 
  		 t.team_long_name AS hometeam, m.home_goal
  FROM match AS m
  LEFT JOIN team AS t 
  ON m.hometeam_id = t.team_api_id),
-- Declare and set up the away CTE
away AS (
  SELECT m.id, m.date, 
  		 t.team_long_name AS awayteam, m.away_goal
  FROM match AS m
  LEFT JOIN team AS t 
  ON m.awayteam_id = t.team_api_id)
-- Select date, home_goal, and away_goal
SELECT 
	home.date,
    home.hometeam,
    away.awayteam,
    home.home_goal,
    away.away_goal
-- Join away and home on the id column
FROM home
INNER JOIN away
ON home.id = away.id;

And you're done!! You now know three separate ways to manipulate and transform data to produce a complex query result! This is a great set of skills to have when working with complex relational databases!







